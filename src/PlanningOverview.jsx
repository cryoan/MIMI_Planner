import React from "react";
import { format } from "date-fns";
import { fr } from "date-fns/locale";
import { activityColors } from "./schedule";
import { ScheduleContext } from "./ScheduleContext";
import { rotation_cycles } from "./customPlanningLogic";

const PlanningOverview = ({ customScheduleData, onPeriodClick }) => {
  const days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  const timeSlots = ["9am-1pm", "2pm-6pm"];
  const [showDetailedBreakdown, setShowDetailedBreakdown] =
    React.useState(false);

  // ‚úÖ Use dynamic expectedActivities from ScheduleContext
  const scheduleContext = React.useContext(ScheduleContext);
  const expectedActivities = scheduleContext?.expectedActivities || {};
  const selectedRotationCycle = scheduleContext?.selectedRotationCycle || "honeymoon_NS_noHDJ";

  // Get periods directly from custom planning logic results
  const getPeriods = () => {
    if (!customScheduleData || !customScheduleData.periodicSchedule) {
      return [];
    }

    // Return periods as they are generated by the custom planning algorithm
    return Object.keys(customScheduleData.periodicSchedule).map(
      (periodName) => {
        return { name: periodName };
      }
    );
  };

  // Aggregate validation results for a period using direct schedule data
  const aggregateValidationForPeriod = (period) => {
    let totalMissing = 0;
    let totalDuplicates = 0;
    let totalSlots = 0;
    let validSlots = 0;

    const scheduleData = getPeriodScheduleData(period);

    if (scheduleData) {
      days.forEach((day) => {
        const fullDay = dayMap[day];
        timeSlots.forEach((slot) => {
          const validation = validateScheduleData(scheduleData, fullDay, slot);
          totalSlots++;
          totalMissing += validation.missing.length;
          totalDuplicates += validation.duplicates.length;

          if (!validation.hasConflicts) {
            validSlots++;
          }
        });
      });
    }

    return {
      totalMissing,
      totalDuplicates,
      totalSlots,
      validSlots,
      healthStatus:
        totalMissing + totalDuplicates === 0
          ? "good"
          : totalMissing + totalDuplicates < 5
          ? "warning"
          : "error",
    };
  };

  // Helper function to find duplicates in an array
  const findDuplicates = (arr) => {
    const duplicateActivities = [
      "EMIT",
      "HDJ",
      "AMI",
      "HTC1",
      "HTC2",
      "EMATIT",
    ];
    const counts = {};
    const duplicates = [];

    arr.forEach((item) => {
      if (duplicateActivities.includes(item)) {
        counts[item] = (counts[item] || 0) + 1;
      }
    });

    Object.keys(counts).forEach((item) => {
      if (counts[item] > 1) {
        duplicates.push(item);
      }
    });

    return duplicates;
  };

  // Direct schedule data validation function
  const validateScheduleData = (scheduleData, day, slot) => {
    if (!scheduleData) {
      return {
        missing: [],
        duplicates: [],
        hasConflicts: false,
      };
    }

    // Get all activities assigned by all doctors for this day/slot
    const assigned = [];
    Object.keys(scheduleData).forEach((doctor) => {
      const activities = scheduleData[doctor]?.[day]?.[slot] || [];
      assigned.push(...activities);
    });

    // Compare against expected activities
    const expected = expectedActivities[day]?.[slot] || [];
    const missing = expected.filter((activity) => !assigned.includes(activity));

    // Check for duplicates
    const duplicates = findDuplicates(assigned);

    return {
      missing,
      duplicates,
      hasConflicts: missing.length > 0 || duplicates.length > 0,
    };
  };

  // Get slot-level validation (AM or PM specific) using direct schedule data
  const getSlotValidation = (period, day, slot) => {
    const fullDay = dayMap[day];
    const scheduleData = getPeriodScheduleData(period);

    return validateScheduleData(scheduleData, fullDay, slot);
  };

  // Day mapping for consistency
  const dayMap = {
    Mon: "Monday",
    Tue: "Tuesday",
    Wed: "Wednesday",
    Thu: "Thursday",
    Fri: "Friday",
    Sat: "Saturday",
    Sun: "Sunday",
  };

  // Get period schedule data directly from custom planning logic results
  const getPeriodScheduleData = (period) => {
    if (customScheduleData && customScheduleData.periodicSchedule) {
      const periodData = customScheduleData.periodicSchedule[period.name];
      if (periodData && periodData.schedule) {
        return periodData.schedule;
      }
    }
    return null;
  };

  // Get global summary across all periods
  const getGlobalSummary = () => {
    const periods = getPeriods();
    let totalMissing = 0;
    let totalDuplicates = 0;
    let totalSlots = 0;
    let validSlots = 0;
    let affectedPeriods = 0;

    periods.forEach((period) => {
      const validation = aggregateValidationForPeriod(period);
      totalMissing += validation.totalMissing;
      totalDuplicates += validation.totalDuplicates;
      totalSlots += validation.totalSlots;
      validSlots += validation.validSlots;

      if (validation.totalMissing > 0 || validation.totalDuplicates > 0) {
        affectedPeriods++;
      }
    });

    const healthStatus =
      totalMissing + totalDuplicates === 0
        ? "good"
        : totalMissing + totalDuplicates < 10
        ? "warning"
        : "error";

    return {
      totalMissing,
      totalDuplicates,
      totalSlots,
      validSlots,
      affectedPeriods,
      totalPeriods: periods.length,
      healthStatus,
    };
  };

  // Get detailed breakdown of missing and duplicate activities by type
  const getDetailedBreakdown = () => {
    const periods = getPeriods();
    const missingByActivity = {};
    const duplicatesByActivity = {};
    const periodBreakdown = {};

    periods.forEach((period) => {
      const scheduleData = getPeriodScheduleData(period);
      const periodMissing = {};
      const periodDuplicates = {};

      if (scheduleData) {
        days.forEach((day) => {
          const fullDay = dayMap[day];
          timeSlots.forEach((slot) => {
            const validation = validateScheduleData(
              scheduleData,
              fullDay,
              slot
            );

            // Count missing activities
            validation.missing.forEach((activity) => {
              missingByActivity[activity] =
                (missingByActivity[activity] || 0) + 1;
              periodMissing[activity] = (periodMissing[activity] || 0) + 1;
            });

            // Count duplicate activities
            validation.duplicates.forEach((activity) => {
              duplicatesByActivity[activity] =
                (duplicatesByActivity[activity] || 0) + 1;
              periodDuplicates[activity] =
                (periodDuplicates[activity] || 0) + 1;
            });
          });
        });
      }

      // Store period-specific breakdown only if there are issues
      if (
        Object.keys(periodMissing).length > 0 ||
        Object.keys(periodDuplicates).length > 0
      ) {
        periodBreakdown[period.name] = {
          missing: periodMissing,
          duplicates: periodDuplicates,
        };
      }
    });

    return {
      missingByActivity,
      duplicatesByActivity,
      periodBreakdown,
    };
  };

  // Simple date generation for display purposes
  const getDisplayDates = () => {
    // Generate dates for Monday-Friday display
    const today = new Date();
    const monday = new Date(today);
    monday.setDate(today.getDate() - today.getDay() + 1);

    return Array.from({ length: 7 }, (_, i) => {
      const date = new Date(monday);
      date.setDate(monday.getDate() + i);
      return date;
    });
  };

  // Render global summary component
  const renderGlobalSummary = () => {
    const summary = getGlobalSummary();

    return (
      <div className="global-summary-container">
        <div className="summary-card">
          <div className="summary-header">
            <div className={`summary-health-badge ${summary.healthStatus}`}>
              {summary.healthStatus === "good"
                ? "‚úÖ OK"
                : summary.healthStatus === "warning"
                ? "‚ö†Ô∏è Attention"
                : "‚ùå Critique"}
            </div>
          </div>

          <div className="summary-stats">
            <div className="stat-item">
              <span className="stat-number">
                {summary.totalMissing + summary.totalDuplicates}
              </span>
              <span className="stat-label">Probl√®mes totaux</span>
            </div>
            <div className="stat-item">
              <span className="stat-number">{summary.totalMissing}</span>
              <span className="stat-label">Activit√©s manquantes</span>
            </div>
            <div className="stat-item">
              <span className="stat-number">{summary.totalDuplicates}</span>
              <span className="stat-label">Activit√©s dupliqu√©es</span>
            </div>
          </div>

          {(summary.totalMissing > 0 || summary.totalDuplicates > 0) && (
            <button
              className="breakdown-toggle"
              onClick={() => setShowDetailedBreakdown(!showDetailedBreakdown)}
            >
              {showDetailedBreakdown
                ? "üîº Masquer le d√©tail"
                : "üîΩ Voir le d√©tail par activit√©"}
            </button>
          )}
        </div>
      </div>
    );
  };

  // Render detailed breakdown component
  const renderDetailedBreakdown = () => {
    if (!showDetailedBreakdown) return null;

    const breakdown = getDetailedBreakdown();
    const hasIssues =
      Object.keys(breakdown.missingByActivity).length > 0 ||
      Object.keys(breakdown.duplicatesByActivity).length > 0;

    if (!hasIssues) return null;

    return (
      <div className="detailed-breakdown-container">
        <div className="breakdown-content">
          {Object.keys(breakdown.missingByActivity).length > 0 && (
            <div className="breakdown-section">
              <h5>‚ùå Activit√©s manquantes par type</h5>
              <div className="activity-counts">
                {Object.entries(breakdown.missingByActivity).map(
                  ([activity, count]) => (
                    <div
                      key={`missing-${activity}`}
                      className="activity-count-item missing"
                    >
                      <span
                        className="activity-name"
                        style={{
                          backgroundColor:
                            activityColors[activity] || "#f0f0f0",
                          color: activityColors[activity] ? "white" : "black",
                        }}
                      >
                        {activity}
                      </span>
                      <span className="activity-count">{count} fois</span>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {Object.keys(breakdown.duplicatesByActivity).length > 0 && (
            <div className="breakdown-section">
              <h5>‚ö†Ô∏è Activit√©s dupliqu√©es par type</h5>
              <div className="activity-counts">
                {Object.entries(breakdown.duplicatesByActivity).map(
                  ([activity, count]) => (
                    <div
                      key={`duplicate-${activity}`}
                      className="activity-count-item duplicate"
                    >
                      <span
                        className="activity-name"
                        style={{
                          backgroundColor:
                            activityColors[activity] || "#f0f0f0",
                          color: activityColors[activity] ? "white" : "black",
                        }}
                      >
                        {activity}
                      </span>
                      <span className="activity-count">{count} fois</span>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {Object.keys(breakdown.periodBreakdown).length > 0 && (
            <div className="breakdown-section">
              <h5>üìÖ D√©tail par p√©riode</h5>
              <div className="period-breakdown">
                {Object.entries(breakdown.periodBreakdown).map(
                  ([periodName, periodData]) => (
                    <div key={periodName} className="period-breakdown-item">
                      <strong>{periodName}:</strong>
                      {Object.keys(periodData.missing).length > 0 && (
                        <span className="period-issues missing">
                          Manquants:{" "}
                          {Object.entries(periodData.missing)
                            .map(([activity, count]) => `${activity}(${count})`)
                            .join(", ")}
                        </span>
                      )}
                      {Object.keys(periodData.duplicates).length > 0 && (
                        <span className="period-issues duplicate">
                          Doublons:{" "}
                          {Object.entries(periodData.duplicates)
                            .map(([activity, count]) => `${activity}(${count})`)
                            .join(", ")}
                        </span>
                      )}
                    </div>
                  )
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  // Render a mini calendar for a period
  const renderPeriodMiniCalendar = (period, validation) => {
    const weekData = getPeriodScheduleData(period);

    if (!weekData) return null;

    const dates = getDisplayDates();

    return (
      <div className="mini-calendar" key={period.name}>
        <div className="period-header">
          <h4>{period.name}</h4>
          <div className={`validation-badge ${validation.healthStatus}`}>
            {validation.totalMissing + validation.totalDuplicates === 0
              ? "‚úì"
              : `‚ö†Ô∏è ${validation.totalMissing + validation.totalDuplicates}`}
          </div>
        </div>

        <table className="mini-calendar-table">
          <thead>
            <tr>
              <th></th>
              {days.map((day, index) => (
                <th key={day} colSpan="2" className="mini-day-header">
                  <div className="day-name">{day}</div>
                  <div className="day-date">{dates[index].getDate()}</div>
                </th>
              ))}
            </tr>
            <tr>
              <th></th>
              {days.map((day) => (
                <React.Fragment key={day}>
                  <th className="mini-slot">AM</th>
                  <th className="mini-slot">PM</th>
                </React.Fragment>
              ))}
            </tr>
            <tr className="day-conflicts-row">
              <td className="conflicts-label">Issues</td>
              {days.map((day) => (
                <React.Fragment key={`conflicts-${day}`}>
                  {timeSlots.map((slot) => {
                    const slotValidation = getSlotValidation(period, day, slot);
                    const slotLabel = slot === "9am-1pm" ? "AM" : "PM";

                    return (
                      <td
                        key={`conflicts-${day}-${slot}`}
                        className="slot-conflict-summary"
                      >
                        {!slotValidation.hasConflicts ? (
                          <span className="conflict-ok">‚úì</span>
                        ) : (
                          <div className="conflict-details">
                            {slotValidation.missing.length > 0 && (
                              <div className="conflict-missing">
                                ‚ùå {slotValidation.missing.join(", ")}
                              </div>
                            )}
                            {slotValidation.duplicates.length > 0 && (
                              <div className="conflict-duplicate">
                                ‚ö†Ô∏è {slotValidation.duplicates.join(", ")}
                              </div>
                            )}
                          </div>
                        )}
                      </td>
                    );
                  })}
                </React.Fragment>
              ))}
            </tr>
          </thead>
          <tbody>
            {Object.keys(weekData).map((doctor) => (
              <tr key={doctor}>
                <td className="doctor-name">{doctor}</td>
                {days.map((day) => (
                  <React.Fragment key={doctor + day}>
                    {timeSlots.map((slot) => {
                      const fullDay = dayMap[day];
                      const activities = weekData[doctor]?.[fullDay]?.[
                        slot
                      ] || ["free"];

                      return (
                        <td
                          key={doctor + day + slot}
                          className="mini-activity-cell"
                        >
                          <div className="mini-activities">
                            {activities.slice(0, 2).map((activity, idx) => (
                              <div
                                key={activity + idx}
                                className="mini-activity"
                                style={{
                                  backgroundColor:
                                    activityColors[activity] || "white",
                                  color: activityColors[activity]
                                    ? "white"
                                    : "black",
                                }}
                              >
                                {activity.length > 4
                                  ? activity.substring(0, 3) + "."
                                  : activity}
                              </div>
                            ))}
                            {activities.length > 2 && (
                              <div className="mini-activity-more">
                                +{activities.length - 2}
                              </div>
                            )}
                          </div>
                        </td>
                      );
                    })}
                  </React.Fragment>
                ))}
              </tr>
            ))}
          </tbody>
        </table>

        {(validation.totalMissing > 0 || validation.totalDuplicates > 0) && (
          <div className="period-summary">
            {validation.totalMissing > 0 && (
              <span className="missing-count">
                Manquants: {validation.totalMissing}
              </span>
            )}
            {validation.totalDuplicates > 0 && (
              <span className="duplicate-count">
                Doublons: {validation.totalDuplicates}
              </span>
            )}
          </div>
        )}
      </div>
    );
  };

  const periods = getPeriods();

  // Format rotation cycle name for display
  const formatCycleName = (cycleKey) => {
    return cycleKey.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  };

  const cycleDescription = rotation_cycles[selectedRotationCycle]?.description || "";

  return (
    <div className="planning-overview-container">
      <div className="overview-header">
        <h3>
          Probl√®mes durant l'ensemble du cycle: {formatCycleName(selectedRotationCycle)}
          {cycleDescription && (
            <div style={{
              fontSize: '14px',
              fontWeight: 'normal',
              fontStyle: 'italic',
              color: '#6c757d',
              marginTop: '4px'
            }}>
              {cycleDescription}
            </div>
          )}
        </h3>
      </div>

      {renderGlobalSummary()}
      {renderDetailedBreakdown()}

      <div className="period-grid">
        {periods.map((period) => {
          const validation = aggregateValidationForPeriod(period);
          return (
            <div
              key={period.name}
              className="period-container"
              onClick={() => onPeriodClick && onPeriodClick(period)}
            >
              {renderPeriodMiniCalendar(period, validation)}
            </div>
          );
        })}
      </div>

      <div className="overview-legend">
        <div className="legend-item">
          <span className="legend-indicator good">‚úì</span>
          <span>Aucun probl√®me</span>
        </div>
        <div className="legend-item">
          <span className="legend-indicator warning">‚ö†Ô∏è</span>
          <span>Probl√®mes mineurs (&lt; 5)</span>
        </div>
        <div className="legend-item">
          <span className="legend-indicator error">‚ö†Ô∏è</span>
          <span>Probl√®mes majeurs (‚â• 5)</span>
        </div>
      </div>
    </div>
  );
};

export default PlanningOverview;
