import React from "react";
import { format } from "date-fns";
import { fr } from "date-fns/locale";
import { activityColors } from "./schedule";
import { ScheduleContext } from "./ScheduleContext";
import { rotation_cycles } from "./customPlanningLogic";
import { docActivities } from "./doctorSchedules";

const PlanningOverview = ({ customScheduleData, onPeriodClick }) => {
  const days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  const timeSlots = ["9am-1pm", "2pm-6pm"];
  const [showDetailedBreakdown, setShowDetailedBreakdown] =
    React.useState(false);
  const [overloadThreshold, setOverloadThreshold] = React.useState(2);

  // ‚úÖ Use dynamic expectedActivities from ScheduleContext
  const scheduleContext = React.useContext(ScheduleContext);
  const expectedActivities = scheduleContext?.expectedActivities || {};
  const selectedRotationCycle = scheduleContext?.selectedRotationCycle || "honeymoon_NS_noHDJ";

  // Get periods directly from custom planning logic results
  const getPeriods = () => {
    if (!customScheduleData || !customScheduleData.periodicSchedule) {
      return [];
    }

    // Return periods as they are generated by the custom planning algorithm
    return Object.keys(customScheduleData.periodicSchedule).map(
      (periodName) => {
        return { name: periodName };
      }
    );
  };

  // Aggregate validation results for a period using direct schedule data
  const aggregateValidationForPeriod = (period) => {
    let totalMissing = 0;
    let totalDuplicates = 0;
    let totalOverloadedSlots = 0; // Count of slots with doctor overloads
    let totalSlots = 0;
    let validSlots = 0;

    const scheduleData = getPeriodScheduleData(period);

    if (scheduleData) {
      days.forEach((day) => {
        const fullDay = dayMap[day];
        timeSlots.forEach((slot) => {
          const validation = validateScheduleData(scheduleData, fullDay, slot);
          totalSlots++;
          totalMissing += validation.missing.length;
          totalDuplicates += validation.duplicates.length;

          // Count slots where at least one doctor has an overload
          if (validation.doctorOverloads && validation.doctorOverloads.length > 0) {
            totalOverloadedSlots += validation.doctorOverloads.length;
          }

          if (!validation.hasConflicts) {
            validSlots++;
          }
        });
      });
    }

    const totalIssues = totalMissing + totalDuplicates + totalOverloadedSlots;

    return {
      totalMissing,
      totalDuplicates,
      totalOverloadedSlots,
      totalSlots,
      validSlots,
      healthStatus:
        totalIssues === 0 ? "good" : totalIssues < 5 ? "warning" : "error",
    };
  };

  // Helper function to calculate total duration of activities in a slot
  const calculateSlotDuration = (activities) => {
    if (!Array.isArray(activities)) {
      return 0;
    }

    return activities.reduce((total, activity) => {
      const activityInfo = docActivities[activity];
      if (activityInfo && typeof activityInfo.duration === "number") {
        return total + activityInfo.duration;
      }
      // If activity not found, assume 1 hour (conservative for unknown activities)
      return total + 1;
    }, 0);
  };

  // Helper function to check for duration violations for a specific doctor in a slot
  const calculateDoctorSlotOverload = (doctorSchedule, day, slot) => {
    if (!doctorSchedule || !doctorSchedule[day] || !doctorSchedule[day][slot]) {
      return null;
    }

    const activities = doctorSchedule[day][slot] || [];

    // If doctor has TP, the slot is blocked (no overload calculation needed)
    if (activities.includes("TP")) {
      return null;
    }

    const totalDuration = calculateSlotDuration(activities);
    const MAX_SLOT_CAPACITY = 4;

    if (totalDuration > MAX_SLOT_CAPACITY) {
      return {
        totalDuration,
        maxCapacity: MAX_SLOT_CAPACITY,
        overCapacity: totalDuration - MAX_SLOT_CAPACITY,
        activities: activities,
      };
    }

    return null;
  };

  // Helper function to find duplicates in an array
  const findDuplicates = (arr) => {
    const duplicateActivities = [
      "EMIT",
      "HDJ",
      "AMI",
      "HTC1",
      "HTC2",
      "EMATIT",
    ];
    const counts = {};
    const duplicates = [];

    arr.forEach((item) => {
      if (duplicateActivities.includes(item)) {
        counts[item] = (counts[item] || 0) + 1;
      }
    });

    Object.keys(counts).forEach((item) => {
      if (counts[item] > 1) {
        duplicates.push(item);
      }
    });

    return duplicates;
  };

  // Direct schedule data validation function
  const validateScheduleData = (scheduleData, day, slot) => {
    if (!scheduleData) {
      return {
        missing: [],
        duplicates: [],
        doctorOverloads: [],
        hasConflicts: false,
      };
    }

    // Get all activities assigned by all doctors for this day/slot
    const assigned = [];
    Object.keys(scheduleData).forEach((doctor) => {
      const activities = scheduleData[doctor]?.[day]?.[slot] || [];
      assigned.push(...activities);
    });

    // Compare against expected activities
    const expected = expectedActivities[day]?.[slot] || [];
    const missing = expected.filter((activity) => !assigned.includes(activity));

    // Check for duplicates
    const duplicates = findDuplicates(assigned);

    // Check for per-doctor duration violations
    const doctorOverloads = [];
    Object.keys(scheduleData).forEach((doctorCode) => {
      const overload = calculateDoctorSlotOverload(
        scheduleData[doctorCode],
        day,
        slot
      );
      if (overload) {
        doctorOverloads.push({
          doctor: doctorCode,
          ...overload,
        });
      }
    });

    return {
      missing,
      duplicates,
      doctorOverloads,
      hasConflicts:
        missing.length > 0 ||
        duplicates.length > 0 ||
        doctorOverloads.length > 0,
    };
  };

  // Get slot-level validation (AM or PM specific) using direct schedule data
  const getSlotValidation = (period, day, slot) => {
    const fullDay = dayMap[day];
    const scheduleData = getPeriodScheduleData(period);

    return validateScheduleData(scheduleData, fullDay, slot);
  };

  // Day mapping for consistency
  const dayMap = {
    Mon: "Monday",
    Tue: "Tuesday",
    Wed: "Wednesday",
    Thu: "Thursday",
    Fri: "Friday",
    Sat: "Saturday",
    Sun: "Sunday",
  };

  // Get period schedule data directly from custom planning logic results
  const getPeriodScheduleData = (period) => {
    if (customScheduleData && customScheduleData.periodicSchedule) {
      const periodData = customScheduleData.periodicSchedule[period.name];
      if (periodData && periodData.schedule) {
        return periodData.schedule;
      }
    }
    return null;
  };

  // Get global summary across all periods
  const getGlobalSummary = () => {
    const periods = getPeriods();
    let totalMissing = 0;
    let totalDuplicates = 0;
    let totalOverloadedSlots = 0;
    let totalSlots = 0;
    let validSlots = 0;
    let affectedPeriods = 0;

    periods.forEach((period) => {
      const validation = aggregateValidationForPeriod(period);
      totalMissing += validation.totalMissing;
      totalDuplicates += validation.totalDuplicates;
      totalOverloadedSlots += validation.totalOverloadedSlots;
      totalSlots += validation.totalSlots;
      validSlots += validation.validSlots;

      if (
        validation.totalMissing > 0 ||
        validation.totalDuplicates > 0 ||
        validation.totalOverloadedSlots > 0
      ) {
        affectedPeriods++;
      }
    });

    const totalIssues = totalMissing + totalDuplicates + totalOverloadedSlots;
    const healthStatus =
      totalIssues === 0 ? "good" : totalIssues < 10 ? "warning" : "error";

    return {
      totalMissing,
      totalDuplicates,
      totalOverloadedSlots,
      totalSlots,
      validSlots,
      affectedPeriods,
      totalPeriods: periods.length,
      healthStatus,
    };
  };

  // Get detailed breakdown of missing and duplicate activities by type
  const getDetailedBreakdown = () => {
    const periods = getPeriods();
    const missingByActivity = {};
    const duplicatesByActivity = {};
    const doctorOverloads = {}; // Map: doctorCode -> { totalSlots, totalHours, violations[] }
    const periodBreakdown = {};

    periods.forEach((period) => {
      const scheduleData = getPeriodScheduleData(period);
      const periodMissing = {};
      const periodDuplicates = {};
      const periodDoctorOverloads = {}; // Per-period doctor overloads

      if (scheduleData) {
        days.forEach((day) => {
          const fullDay = dayMap[day];
          timeSlots.forEach((slot) => {
            const validation = validateScheduleData(
              scheduleData,
              fullDay,
              slot
            );

            // Count missing activities
            validation.missing.forEach((activity) => {
              missingByActivity[activity] =
                (missingByActivity[activity] || 0) + 1;
              periodMissing[activity] = (periodMissing[activity] || 0) + 1;
            });

            // Count duplicate activities
            validation.duplicates.forEach((activity) => {
              duplicatesByActivity[activity] =
                (duplicatesByActivity[activity] || 0) + 1;
              periodDuplicates[activity] =
                (periodDuplicates[activity] || 0) + 1;
            });

            // Track per-doctor overloads
            validation.doctorOverloads.forEach((overload) => {
              const doctorCode = overload.doctor;

              // Initialize global doctor overload tracking
              if (!doctorOverloads[doctorCode]) {
                doctorOverloads[doctorCode] = {
                  totalSlots: 0,
                  totalHours: 0,
                  violations: [],
                };
              }

              // Initialize period-specific doctor overload tracking
              if (!periodDoctorOverloads[doctorCode]) {
                periodDoctorOverloads[doctorCode] = {
                  totalSlots: 0,
                  totalHours: 0,
                  violations: [],
                };
              }

              const violation = {
                period: period.name,
                day: fullDay,
                slot,
                totalDuration: overload.totalDuration,
                overCapacity: overload.overCapacity,
                activities: overload.activities,
              };

              // Add to global tracking
              doctorOverloads[doctorCode].totalSlots += 1;
              doctorOverloads[doctorCode].totalHours += overload.overCapacity;
              doctorOverloads[doctorCode].violations.push(violation);

              // Add to period tracking
              periodDoctorOverloads[doctorCode].totalSlots += 1;
              periodDoctorOverloads[doctorCode].totalHours +=
                overload.overCapacity;
              periodDoctorOverloads[doctorCode].violations.push(violation);
            });
          });
        });
      }

      // Store period-specific breakdown only if there are issues
      if (
        Object.keys(periodMissing).length > 0 ||
        Object.keys(periodDuplicates).length > 0 ||
        Object.keys(periodDoctorOverloads).length > 0
      ) {
        periodBreakdown[period.name] = {
          missing: periodMissing,
          duplicates: periodDuplicates,
          doctorOverloads: periodDoctorOverloads,
        };
      }
    });

    return {
      missingByActivity,
      duplicatesByActivity,
      doctorOverloads,
      periodBreakdown,
    };
  };

  // Simple date generation for display purposes
  const getDisplayDates = () => {
    // Generate dates for Monday-Friday display
    const today = new Date();
    const monday = new Date(today);
    monday.setDate(today.getDate() - today.getDay() + 1);

    return Array.from({ length: 7 }, (_, i) => {
      const date = new Date(monday);
      date.setDate(monday.getDate() + i);
      return date;
    });
  };

  // Render global summary component
  const renderGlobalSummary = () => {
    const summary = getGlobalSummary();

    return (
      <div className="global-summary-container">
        <div className="summary-card">
          <div className="summary-header">
            <div className={`summary-health-badge ${summary.healthStatus}`}>
              {summary.healthStatus === "good"
                ? "‚úÖ OK"
                : summary.healthStatus === "warning"
                ? "‚ö†Ô∏è Attention"
                : "‚ùå Critique"}
            </div>
          </div>

          <div className="summary-stats">
            <div className="stat-item">
              <span className="stat-number">
                {summary.totalMissing +
                  summary.totalDuplicates +
                  summary.totalOverloadedSlots}
              </span>
              <span className="stat-label">Probl√®mes totaux</span>
            </div>
            <div className="stat-item">
              <span className="stat-number">{summary.totalMissing}</span>
              <span className="stat-label">Activit√©s manquantes</span>
            </div>
            <div className="stat-item">
              <span className="stat-number">{summary.totalDuplicates}</span>
              <span className="stat-label">Activit√©s dupliqu√©es</span>
            </div>
            <div className="stat-item">
              <span className="stat-number">
                {summary.totalOverloadedSlots}
              </span>
              <span className="stat-label">Cr√©neaux surcharg√©s</span>
            </div>
          </div>

          <div className="overload-threshold-control">
            <label htmlFor="overload-threshold">
              üî¥ Seuil d'alerte surcharge:
            </label>
            <input
              id="overload-threshold"
              type="number"
              min="0"
              max="4"
              step="1"
              value={overloadThreshold}
              onChange={(e) => setOverloadThreshold(parseInt(e.target.value, 10))}
              style={{
                marginLeft: "8px",
                width: "60px",
                padding: "4px 8px",
                border: "1px solid #ccc",
                borderRadius: "4px",
              }}
            />
            <span style={{ marginLeft: "4px" }}>heures</span>
          </div>

          {(summary.totalMissing > 0 ||
            summary.totalDuplicates > 0 ||
            summary.totalOverloadedSlots > 0) && (
            <button
              className="breakdown-toggle"
              onClick={() => setShowDetailedBreakdown(!showDetailedBreakdown)}
            >
              {showDetailedBreakdown
                ? "üîº Masquer le d√©tail"
                : "üîΩ Voir le d√©tail par activit√©"}
            </button>
          )}
        </div>
      </div>
    );
  };

  // Render detailed breakdown component
  const renderDetailedBreakdown = () => {
    if (!showDetailedBreakdown) return null;

    const breakdown = getDetailedBreakdown();
    const hasIssues =
      Object.keys(breakdown.missingByActivity).length > 0 ||
      Object.keys(breakdown.duplicatesByActivity).length > 0 ||
      Object.keys(breakdown.doctorOverloads).length > 0;

    if (!hasIssues) return null;

    return (
      <div className="detailed-breakdown-container">
        <div className="breakdown-content">
          {Object.keys(breakdown.missingByActivity).length > 0 && (
            <div className="breakdown-section">
              <h5>‚ùå Activit√©s manquantes par type</h5>
              <div className="activity-counts">
                {Object.entries(breakdown.missingByActivity).map(
                  ([activity, count]) => (
                    <div
                      key={`missing-${activity}`}
                      className="activity-count-item missing"
                    >
                      <span
                        className="activity-name"
                        style={{
                          backgroundColor:
                            activityColors[activity] || "#f0f0f0",
                          color: activityColors[activity] ? "white" : "black",
                        }}
                      >
                        {activity}
                      </span>
                      <span className="activity-count">{count} fois</span>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {Object.keys(breakdown.duplicatesByActivity).length > 0 && (
            <div className="breakdown-section">
              <h5>‚ö†Ô∏è Activit√©s dupliqu√©es par type</h5>
              <div className="activity-counts">
                {Object.entries(breakdown.duplicatesByActivity).map(
                  ([activity, count]) => (
                    <div
                      key={`duplicate-${activity}`}
                      className="activity-count-item duplicate"
                    >
                      <span
                        className="activity-name"
                        style={{
                          backgroundColor:
                            activityColors[activity] || "#f0f0f0",
                          color: activityColors[activity] ? "white" : "black",
                        }}
                      >
                        {activity}
                      </span>
                      <span className="activity-count">{count} fois</span>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {Object.keys(breakdown.doctorOverloads).length > 0 && (
            <div className="breakdown-section">
              <h5>‚è±Ô∏è Surcharges par m√©decin (4h max/plage)</h5>
              <div className="doctor-overloads">
                {Object.entries(breakdown.doctorOverloads)
                  .sort((a, b) => b[1].totalSlots - a[1].totalSlots) // Sort by most violations first
                  .map(([doctorCode, overloadData]) => (
                    <div key={doctorCode} className="doctor-overload-item">
                      <div className="doctor-overload-header">
                        <strong>{doctorCode}:</strong>
                        <span className="overload-summary">
                          {overloadData.totalSlots} cr√©neau
                          {overloadData.totalSlots > 1 ? "x" : ""} surcharg√©
                          {overloadData.totalSlots > 1 ? "s" : ""} (
                          {overloadData.totalHours}h d'exc√®s)
                        </span>
                      </div>
                      <div className="doctor-violations-list">
                        {overloadData.violations.map((violation, idx) => (
                          <div key={idx} className="violation-detail">
                            ‚Ä¢ {violation.day} {violation.slot}:{" "}
                            {violation.totalDuration}h/4h
                            <strong
                              style={{ color: "#d32f2f", marginLeft: "4px" }}
                            >
                              (+{violation.overCapacity}h)
                            </strong>
                            <span
                              style={{
                                fontSize: "0.9em",
                                marginLeft: "8px",
                                color: "#666",
                              }}
                            >
                              [{violation.activities.join(", ")}]
                            </span>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          )}

          {Object.keys(breakdown.periodBreakdown).length > 0 && (
            <div className="breakdown-section">
              <h5>üìÖ D√©tail par p√©riode</h5>
              <div className="period-breakdown">
                {Object.entries(breakdown.periodBreakdown).map(
                  ([periodName, periodData]) => (
                    <div key={periodName} className="period-breakdown-item">
                      <strong>{periodName}:</strong>
                      {Object.keys(periodData.missing).length > 0 && (
                        <span className="period-issues missing">
                          Manquants:{" "}
                          {Object.entries(periodData.missing)
                            .map(([activity, count]) => `${activity}(${count})`)
                            .join(", ")}
                        </span>
                      )}
                      {Object.keys(periodData.duplicates).length > 0 && (
                        <span className="period-issues duplicate">
                          Doublons:{" "}
                          {Object.entries(periodData.duplicates)
                            .map(([activity, count]) => `${activity}(${count})`)
                            .join(", ")}
                        </span>
                      )}
                      {periodData.doctorOverloads &&
                        Object.keys(periodData.doctorOverloads).length > 0 && (
                          <div className="period-doctor-overloads">
                            <span className="period-issues duration">
                              Surcharges:{" "}
                            </span>
                            {Object.entries(periodData.doctorOverloads).map(
                              ([doctor, data]) => (
                                <span
                                  key={doctor}
                                  className="period-doctor-overload"
                                >
                                  {doctor}({data.totalSlots} cr√©neau
                                  {data.totalSlots > 1 ? "x" : ""}, {data.totalHours}
                                  h)
                                </span>
                              )
                            )}
                          </div>
                        )}
                    </div>
                  )
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  // Render a mini calendar for a period
  const renderPeriodMiniCalendar = (period, validation) => {
    const weekData = getPeriodScheduleData(period);

    if (!weekData) return null;

    const dates = getDisplayDates();

    return (
      <div className="mini-calendar" key={period.name}>
        <div className="period-header">
          <h4>{period.name}</h4>
          <div className={`validation-badge ${validation.healthStatus}`}>
            {validation.totalMissing +
              validation.totalDuplicates +
              validation.totalOverloadedSlots ===
            0
              ? "‚úì"
              : `‚ö†Ô∏è ${
                  validation.totalMissing +
                  validation.totalDuplicates +
                  validation.totalOverloadedSlots
                }`}
          </div>
        </div>

        <table className="mini-calendar-table">
          <thead>
            <tr>
              <th></th>
              {days.map((day, index) => (
                <th key={day} colSpan="2" className="mini-day-header">
                  <div className="day-name">{day}</div>
                  <div className="day-date">{dates[index].getDate()}</div>
                </th>
              ))}
            </tr>
            <tr>
              <th></th>
              {days.map((day) => (
                <React.Fragment key={day}>
                  <th className="mini-slot">AM</th>
                  <th className="mini-slot">PM</th>
                </React.Fragment>
              ))}
            </tr>
            <tr className="day-conflicts-row">
              <td className="conflicts-label">Issues</td>
              {days.map((day) => (
                <React.Fragment key={`conflicts-${day}`}>
                  {timeSlots.map((slot) => {
                    const slotValidation = getSlotValidation(period, day, slot);
                    const slotLabel = slot === "9am-1pm" ? "AM" : "PM";

                    return (
                      <td
                        key={`conflicts-${day}-${slot}`}
                        className="slot-conflict-summary"
                      >
                        {!slotValidation.hasConflicts ? (
                          <span className="conflict-ok">‚úì</span>
                        ) : (
                          <div className="conflict-details">
                            {slotValidation.missing.length > 0 && (
                              <div className="conflict-missing">
                                ‚ùå {slotValidation.missing.join(", ")}
                              </div>
                            )}
                            {slotValidation.duplicates.length > 0 && (
                              <div className="conflict-duplicate">
                                ‚ö†Ô∏è {slotValidation.duplicates.join(", ")}
                              </div>
                            )}
                            {slotValidation.doctorOverloads &&
                              slotValidation.doctorOverloads.length > 0 && (
                                <div className="conflict-duration">
                                  ‚è±Ô∏è{" "}
                                  {slotValidation.doctorOverloads
                                    .map((o) => `${o.doctor}:${o.totalDuration}h`)
                                    .join(", ")}
                                </div>
                              )}
                          </div>
                        )}
                      </td>
                    );
                  })}
                </React.Fragment>
              ))}
            </tr>
          </thead>
          <tbody>
            {Object.keys(weekData).map((doctor) => (
              <tr key={doctor}>
                <td className="doctor-name">{doctor}</td>
                {days.map((day) => (
                  <React.Fragment key={doctor + day}>
                    {timeSlots.map((slot) => {
                      const fullDay = dayMap[day];
                      const activities = weekData[doctor]?.[fullDay]?.[
                        slot
                      ] || ["free"];

                      // Check for severe overload (>=threshold)
                      const overload = calculateDoctorSlotOverload(
                        weekData[doctor],
                        fullDay,
                        slot
                      );
                      const hasSevereOverload =
                        overload && overload.overCapacity >= overloadThreshold;

                      return (
                        <td
                          key={doctor + day + slot}
                          className="mini-activity-cell"
                          style={
                            hasSevereOverload
                              ? { border: "2px solid #d32f2f" }
                              : {}
                          }
                        >
                          <div className="mini-activities">
                            {activities.slice(0, 2).map((activity, idx) => (
                              <div
                                key={activity + idx}
                                className="mini-activity"
                                style={{
                                  backgroundColor:
                                    activityColors[activity] || "white",
                                  color: activityColors[activity]
                                    ? "white"
                                    : "black",
                                }}
                              >
                                {activity.length > 4
                                  ? activity.substring(0, 3) + "."
                                  : activity}
                              </div>
                            ))}
                            {activities.length > 2 && (
                              <div className="mini-activity-more">
                                +{activities.length - 2}
                              </div>
                            )}
                          </div>
                        </td>
                      );
                    })}
                  </React.Fragment>
                ))}
              </tr>
            ))}
          </tbody>
        </table>

        {(validation.totalMissing > 0 ||
          validation.totalDuplicates > 0 ||
          validation.totalOverloadedSlots > 0) && (
          <div className="period-summary">
            {validation.totalMissing > 0 && (
              <span className="missing-count">
                Manquants: {validation.totalMissing}
              </span>
            )}
            {validation.totalDuplicates > 0 && (
              <span className="duplicate-count">
                Doublons: {validation.totalDuplicates}
              </span>
            )}
            {validation.totalOverloadedSlots > 0 && (
              <span className="duration-count">
                Surcharges: {validation.totalOverloadedSlots}
              </span>
            )}
          </div>
        )}
      </div>
    );
  };

  const periods = getPeriods();

  // Format rotation cycle name for display
  const formatCycleName = (cycleKey) => {
    return cycleKey.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  };

  const cycleDescription = rotation_cycles[selectedRotationCycle]?.description || "";

  return (
    <div className="planning-overview-container">
      <div className="overview-header">
        <h3>
          Probl√®mes durant l'ensemble du cycle: {formatCycleName(selectedRotationCycle)}
          {cycleDescription && (
            <div style={{
              fontSize: '14px',
              fontWeight: 'normal',
              fontStyle: 'italic',
              color: '#6c757d',
              marginTop: '4px'
            }}>
              {cycleDescription}
            </div>
          )}
        </h3>
      </div>

      {renderGlobalSummary()}
      {renderDetailedBreakdown()}

      <div className="period-grid">
        {periods.map((period) => {
          const validation = aggregateValidationForPeriod(period);
          return (
            <div
              key={period.name}
              className="period-container"
              onClick={() => onPeriodClick && onPeriodClick(period)}
            >
              {renderPeriodMiniCalendar(period, validation)}
            </div>
          );
        })}
      </div>

      <div className="overview-legend">
        <div className="legend-item">
          <span className="legend-indicator good">‚úì</span>
          <span>Aucun probl√®me</span>
        </div>
        <div className="legend-item">
          <span className="legend-indicator warning">‚ö†Ô∏è</span>
          <span>Probl√®mes mineurs (&lt; 5)</span>
        </div>
        <div className="legend-item">
          <span className="legend-indicator error">‚ö†Ô∏è</span>
          <span>Probl√®mes majeurs (‚â• 5)</span>
        </div>
        <div className="legend-item">
          <span
            className="legend-indicator"
            style={{
              border: "2px solid #d32f2f",
              padding: "2px 6px",
              borderRadius: "3px",
            }}
          >
            üî¥
          </span>
          <span>Bordure rouge: Surcharge ‚â• {overloadThreshold}h</span>
        </div>
      </div>
    </div>
  );
};

export default PlanningOverview;
